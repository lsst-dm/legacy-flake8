diff -r -u -x .idea -x .git pc/flake8/README.rst flake8/README.rst
--- pc/flake8/README.rst	2018-12-03 22:40:13.000000000 -0800
+++ flake8/README.rst	2018-12-03 15:24:23.000000000 -0800
@@ -19,7 +19,7 @@
 
 - lines that contain a ``# noqa`` comment at the end will not issue warnings.
 - you can ignore specific errors on a line with ``# noqa: <error>``, e.g.,
-  ``# noqa: E234``
+  ``# noqa: E234``. Multiple codes can be given, separated by comma. The ``noqa`` token is case insensitive, the colon before the list of codes is required otherwise the part after ``noqa`` is ignored
 - Git and Mercurial hooks
 - extendable through ``flake8.extension`` and ``flake8.formatting`` entry
   points
diff -r -u -x .idea -x .git pc/flake8/docs/source/internal/utils.rst flake8/docs/source/internal/utils.rst
--- pc/flake8/docs/source/internal/utils.rst	2018-12-03 22:40:13.000000000 -0800
+++ flake8/docs/source/internal/utils.rst	2018-12-03 15:24:23.000000000 -0800
@@ -51,7 +51,7 @@
 .. autofunction:: flake8.utils.normalize_paths
 
 This function utilizes :func:`~flake8.utils.parse_comma_separated_list` and
-:func:`~flake8.utils.normalize_path` to normalize it's input to a list of
+:func:`~flake8.utils.normalize_path` to normalize its input to a list of
 strings that should be paths.
 
 .. autofunction:: flake8.utils.stdin_get_value
diff -r -u -x .idea -x .git pc/flake8/docs/source/internal/writing-documentation.rst flake8/docs/source/internal/writing-documentation.rst
--- pc/flake8/docs/source/internal/writing-documentation.rst	2018-12-03 22:39:46.000000000 -0800
+++ flake8/docs/source/internal/writing-documentation.rst	2018-12-03 15:25:14.000000000 -0800
@@ -70,6 +70,13 @@
 default in |Flake8|. Please wrap lines at 79 characters (or less).
 
 
+Wrap doc lines around 72 characters
+===================================
+
+We use a maximum doc-length in our documentation that is stricter than the
+default in |Flake8|. Please wrap lines at 72 characters (or less).
+
+
 Use two new-lines before new sections
 =====================================
 
diff -r -u -x .idea -x .git pc/flake8/docs/source/manpage.rst flake8/docs/source/manpage.rst
--- pc/flake8/docs/source/manpage.rst	2018-12-03 22:39:46.000000000 -0800
+++ flake8/docs/source/manpage.rst	2018-12-03 15:25:14.000000000 -0800
@@ -59,6 +59,8 @@
                           (Default: E121,E123,E126,E226,E24,E704,W503,W504)
     --max-line-length=n   Maximum allowed line length for the entirety of this
                           run. (Default: 79)
+    --max-doc-length=n    Maximum allowed doc line length for the entirety of
+                          this run.
     --select=errors       Comma-separated list of errors and warnings to enable.
                           For example, ``--select=E4,E51,W234``. (Default:
                           E,F,W,C90)
diff -r -u -x .idea -x .git pc/flake8/docs/source/plugin-development/cross-compatibility.rst flake8/docs/source/plugin-development/cross-compatibility.rst
--- pc/flake8/docs/source/plugin-development/cross-compatibility.rst	2018-12-03 22:40:13.000000000 -0800
+++ flake8/docs/source/plugin-development/cross-compatibility.rst	2018-12-03 15:24:23.000000000 -0800
@@ -161,7 +161,7 @@
 monkey-patched that. 3.0 has its own internal implementation and uses that but
 does not directly provide anything for plugins using pep8 and pycodestyle's
 ``stdin_get_value`` function. |polyfill| provides this functionality for
-plugin developers via it's :mod:`flake8_polyfill.stdin` module.
+plugin developers via its :mod:`flake8_polyfill.stdin` module.
 
 If a plugin needs to read the content from stdin, it can do the following:
 
diff -r -u -x .idea -x .git pc/flake8/docs/source/plugin-development/plugin-parameters.rst flake8/docs/source/plugin-development/plugin-parameters.rst
--- pc/flake8/docs/source/plugin-development/plugin-parameters.rst	2018-12-03 22:39:46.000000000 -0800
+++ flake8/docs/source/plugin-development/plugin-parameters.rst	2018-12-03 15:25:14.000000000 -0800
@@ -48,6 +48,7 @@
 - :attr:`~flake8.processor.FileProcessor.file_tokens`
 - :attr:`~flake8.processor.FileProcessor.lines`
 - :attr:`~flake8.processor.FileProcessor.max_line_length`
+- :attr:`~flake8.processor.FileProcessor.max_doc_length`
 - :attr:`~flake8.processor.FileProcessor.total_lines`
 - :attr:`~flake8.processor.FileProcessor.verbose`
 
diff -r -u -x .idea -x .git pc/flake8/docs/source/release-notes/3.6.0.rst flake8/docs/source/release-notes/3.6.0.rst
--- pc/flake8/docs/source/release-notes/3.6.0.rst	2018-12-03 22:40:13.000000000 -0800
+++ flake8/docs/source/release-notes/3.6.0.rst	2018-12-03 15:24:23.000000000 -0800
@@ -33,7 +33,7 @@
   also `GitLab#405`_, `GitLab!227`_)
 
 - Add ``--extend-ignore`` for extending the default ``ignore`` instead of
-  overriding it (See also `GitLab!233`_)
+  overriding it (See also `GitLab#365`_, `GitLab!233`_)
 
 Bugs Fixed
 ~~~~~~~~~~
@@ -50,7 +50,7 @@
   ``collections`` module (See also `GitLab!249`_)
 
 - Defer ``setuptools`` import to improve flake8 startup time (See also
-  `GitLab#365`_, `GitLab!250`_)
+  `GitLab!250`_)
 
 - Fix inconsistent line endings in ``FileProcessor.lines`` when running under
   python 3.x (See also `GitLab#457`_, `GitLab!255`_)
diff -r -u -x .idea -x .git pc/flake8/docs/source/user/options.rst flake8/docs/source/user/options.rst
--- pc/flake8/docs/source/user/options.rst	2018-12-03 22:40:13.000000000 -0800
+++ flake8/docs/source/user/options.rst	2018-12-03 15:25:14.000000000 -0800
@@ -58,8 +58,12 @@
 
 - :option:`flake8 --extend-ignore`
 
+- :option:`flake8 --per-file-ignores`
+
 - :option:`flake8 --max-line-length`
 
+- :option:`flake8 --max-doc-length`
+
 - :option:`flake8 --select`
 
 - :option:`flake8 --disable-noqa`
@@ -422,6 +426,8 @@
 
     :ref:`Go back to index <top>`
 
+    .. versionadded:: 3.6.0
+
     Specify a list of codes to add to the list of ignored ones. Similar
     considerations as in :option:`--ignore` apply here with regard to the
     value.
@@ -449,6 +455,40 @@
         extend-ignore = E4,E51,W234
 
 
+.. option:: --per-file-ignores=<filename:errors>[ <filename:errors>]
+
+    :ref:`Go back to index <top>`
+
+    .. versionadded:: 3.7.0
+
+    Specify a list of mappings of files and the codes that should be ignored
+    for the entirety of the file. This allows for a project to have a default
+    list of violations that should be ignored as well as file-specific
+    violations for files that have not been made compliant with the project
+    rules.
+
+    This option supports syntax similar to :option:`--exclude` such that glob
+    patterns will also work here.
+
+    This can be combined with both :option:`--ignore` and
+    :option:`--extend-ignore` to achieve a full flexibility of style options.
+
+    Command-line usage:
+
+    .. prompt:: bash
+
+        flake8 --per-file-ignores='project/__init__.py:F401 setup.py:E121'
+        flake8 --per-file-ignores='project/*/__init__.py:F401 setup.py:E121'
+
+    This **can** be specified in config files.
+
+    .. code-block:: ini
+
+        per-file-ignores =
+            project/__init__.py:F401
+            setup.py:E121
+            other_project/*:W9
+
 .. option:: --max-line-length=<n>
 
     :ref:`Go back to index <top>`
@@ -483,6 +523,36 @@
         max-line-length = 79
 
 
+.. option:: --max-doc-length=<n>
+
+    :ref:`Go back to index <top>`
+
+    Set the maximum doc length that any line (with some exceptions) may be.
+
+    Exceptions include lines that are either strings or comments which are
+    entirely URLs. For example:
+
+    .. code-block:: python
+
+        # https://some-super-long-domain-name.com/with/some/very/long/path
+
+    This defaults to off. If you set a number, it will be turned on.
+
+    Command-line example:
+
+    .. prompt:: bash
+
+        flake8 --max-doc-length 72 dir/
+
+    This **can** be specified in config files.
+
+    Example config file usage:
+
+    .. code-block:: ini
+
+        max-doc-length = 72
+
+
 .. option:: --select=<errors>
 
     :ref:`Go back to index <top>`
@@ -743,6 +813,8 @@
 
     :ref:`Go back to index <top>`
 
+    .. versionadded:: 3.6.0
+
     Provide extra config files to parse in after and in addition to the files
     that |Flake8| found on its own. Since these files are the last ones read
     into the Configuration Parser, so it has the highest precedence if it
diff -r -u -x .idea -x .git pc/flake8/docs/source/user/python-api.rst flake8/docs/source/user/python-api.rst
--- pc/flake8/docs/source/user/python-api.rst	2018-12-03 22:40:13.000000000 -0800
+++ flake8/docs/source/user/python-api.rst	2018-12-03 15:24:23.000000000 -0800
@@ -11,7 +11,7 @@
 Legacy API
 ==========
 
-When |Flake8| broke it's hard dependency on the tricky internals of
+When |Flake8| broke its hard dependency on the tricky internals of
 pycodestyle, it lost the easy backwards compatibility as well. To help
 existing users of that API we have :mod:`flake8.api.legacy`. This module
 includes a couple classes (which are documented below) and a function.
diff -r -u -x .idea -x .git pc/flake8/docs/source/user/using-hooks.rst flake8/docs/source/user/using-hooks.rst
--- pc/flake8/docs/source/user/using-hooks.rst	2018-12-03 22:40:13.000000000 -0800
+++ flake8/docs/source/user/using-hooks.rst	2018-12-03 15:24:23.000000000 -0800
@@ -2,6 +2,51 @@
  Using Version Control Hooks
 =============================
 
+Usage with the `pre-commit`_ git hooks framework
+================================================
+
+|Flake8| can be included as a hook for `pre-commit`_.  The easiest way to get
+started is to add this configuration to your ``.pre-commit-config.yaml``:
+
+.. code-block:: yaml
+
+    -   repo: https://gitlab.com/pycqa/flake8
+        rev: ''  # pick a git hash / tag to point to
+        hooks:
+        -   id: flake8
+
+See the `pre-commit docs`_ for how to customize this configuration.
+
+Checked-in python files will be passed as positional arguments.  ``flake8``
+will always lint explicitly passed arguments (:option:`flake8 --exclude` has
+no effect).  Instead use ``pre-commit``'s ``exclude: ...`` regex to exclude
+files.  ``pre-commit`` won't ever pass untracked files to ``flake8`` so
+excluding ``.git`` / ``.tox`` / etc. is unnecesary.
+
+.. code-block:: yaml
+
+        -   id: flake8
+            exclude: ^testing/(data|examples)/
+
+``pre-commit`` creates an isolated environment for hooks.  To use ``flake8``
+plugins, use the ``additional_dependencies`` setting.
+
+.. code-block:: yaml
+
+        -   id: flake8
+            additional_dependencies: [flake8-docstrings]
+
+
+Built-in Hook Integration
+=========================
+
+.. note::
+
+    It is strongly suggested to use |Flake8| via `pre-commit`_ over the
+    built-in hook mechanisms.  ``pre-commit`` smooths out many of the rough
+    edges of ``git`` and is much more battle-tested than the |Flake8|
+    hook impementation.
+
 |Flake8| can be integrated into your development workflow in many ways. A
 default installation of |Flake8| can install pre-commit hooks for both
 `Git`_ and `Mercurial`_. To install a built-in hook, you can use the
@@ -63,6 +108,10 @@
     first.
 
 
+.. _pre-commit:
+    https://pre-commit.com/
+.. _pre-commit docs:
+    https://pre-commit.com/#pre-commit-configyaml---hooks
 .. _Git:
     https://git-scm.com/
 .. _Mercurial:
diff -r -u -x .idea -x .git pc/flake8/docs/source/user/violations.rst flake8/docs/source/user/violations.rst
--- pc/flake8/docs/source/user/violations.rst	2018-12-03 22:40:13.000000000 -0800
+++ flake8/docs/source/user/violations.rst	2018-12-03 15:24:23.000000000 -0800
@@ -18,19 +18,42 @@
 version. To see the default list, :option:`flake8 --help` will
 show the output with the current default list.
 
+Extending the Default Ignore List
+---------------------------------
 
-Changing the Ignore List
-------------------------
+If we want to extend the default list of ignored error codes, we can use
+:option:`flake8 --extend-ignore` to specify a comma-separated list of codes
+for a specific run on the command line, e.g.,
 
-If we want to change the list of ignored codes for a single run, we can use
-:option:`flake8 --ignore` to specify a comma-separated list of codes for a
-specific run on the command-line, e.g.,
+.. prompt:: bash
+
+    flake8 --extend-ignore=E1,E23 path/to/files/ path/to/more/files
+
+This tells |Flake8| to ignore any error codes starting with ``E1`` and ``E23``,
+in addition the default ignore list. To view the default error code ignore
+list, run :option:`flake8 --help` and refer to the help text for
+:option:`flake8 --ignore`.
+
+
+..
+   The section below used to be titled `Changing the Default Ignore List`, but
+   was renamed for clarity.
+   Explicitly retain the old section anchor so as to not break links:
+
+.. _changing-the-ignore-list:
+
+Overriding the Default Ignore List
+----------------------------------
+
+If we want to *completely* override the default list of ignored error codes, we
+can use :option:`flake8 --ignore` to specify a comma-separated list of codes
+for a specific run on the command-line, e.g.,
 
 .. prompt:: bash
 
     flake8 --ignore=E1,E23,W503 path/to/files/ path/to/more/files/
 
-This tells |Flake8| to ignore any error codes starting with ``E1``, ``E23``,
+This tells |Flake8| to *only* ignore error codes starting with ``E1``, ``E23``,
 or ``W503`` while it is running.
 
 .. note::
@@ -62,12 +85,13 @@
 
 This will only ignore the error from pycodestyle that checks for lambda
 assignments and generates an ``E731``. If there are other errors on the line
-then those will be reported.
+then those will be reported. ``# noqa`` is case-insensitive, without the colon
+the part after ``# noqa`` would be ignored.
 
 .. note::
 
     If we ever want to disable |Flake8| respecting ``# noqa`` comments, we can
-    can refer to :option:`flake8 --disable-noqa`.
+    refer to :option:`flake8 --disable-noqa`.
 
 If we instead had more than one error that we wished to ignore, we could
 list all of the errors with commas separating them:
@@ -194,7 +218,7 @@
 ========================================================
 
 Prior to |Flake8| 3.0, all handling of :option:`flake8 --select` and
-:option:`flake8 --ignore` was delegated to pycodestyle. It's handling of the
+:option:`flake8 --ignore` was delegated to pycodestyle. Its handling of the
 options significantly differs from how |Flake8| 3.0 has been designed.
 
 pycodestyle has always preferred ``--ignore`` over ``--select`` and will
diff -r -u -x .idea -x .git pc/flake8/setup.py flake8/setup.py
--- pc/flake8/setup.py	2018-12-03 22:40:13.000000000 -0800
+++ flake8/setup.py	2018-12-03 15:25:14.000000000 -0800
@@ -21,10 +21,10 @@
     # http://flake8.pycqa.org/en/latest/faq.html#why-does-flake8-use-ranges-for-its-dependencies
     # And in which releases we will update those ranges here:
     # http://flake8.pycqa.org/en/latest/internal/releases.html#releasing-flake8
+    "entrypoints >= 0.2.3, < 0.3.0",
     "pyflakes >= 2.0.0, < 2.1.0",
     "pycodestyle >= 2.4.0, < 2.5.0",
     "mccabe >= 0.6.0, < 0.7.0",
-    "setuptools >= 30",
 ]
 
 extras_require = {
@@ -92,6 +92,7 @@
             PEP8_PLUGIN('trailing_whitespace'),
             PEP8_PLUGIN('trailing_blank_lines'),
             PEP8_PLUGIN('maximum_line_length'),
+            PEP8_PLUGIN('maximum_doc_length'),
             PEP8_PLUGIN('blank_lines'),
             PEP8_PLUGIN('extraneous_whitespace'),
             PEP8_PLUGIN('whitespace_around_keywords'),
diff -r -u -x .idea -x .git pc/flake8/src/flake8/__init__.py flake8/src/flake8/__init__.py
--- pc/flake8/src/flake8/__init__.py	2018-12-03 22:40:13.000000000 -0800
+++ flake8/src/flake8/__init__.py	2018-12-03 15:24:23.000000000 -0800
@@ -15,7 +15,7 @@
 LOG = logging.getLogger(__name__)
 LOG.addHandler(logging.NullHandler())
 
-__version__ = "3.6.0"
+__version__ = "3.7.0dev0"
 __version_info__ = tuple(
     int(i) for i in __version__.split(".") if i.isdigit()
 )
diff -r -u -x .idea -x .git pc/flake8/src/flake8/checker.py flake8/src/flake8/checker.py
--- pc/flake8/src/flake8/checker.py	2018-12-03 22:40:13.000000000 -0800
+++ flake8/src/flake8/checker.py	2018-12-03 15:24:23.000000000 -0800
@@ -2,7 +2,6 @@
 import collections
 import errno
 import logging
-import os
 import signal
 import sys
 import tokenize
@@ -188,20 +187,12 @@
                 return False
             path = self.options.stdin_display_name
 
-        exclude = self.options.exclude
-        if not exclude:
-            return False
-        basename = os.path.basename(path)
-        if utils.fnmatch(basename, exclude):
-            LOG.debug('"%s" has been excluded', basename)
-            return True
-
-        absolute_path = os.path.abspath(path)
-        match = utils.fnmatch(absolute_path, exclude)
-        LOG.debug(
-            '"%s" has %sbeen excluded', absolute_path, "" if match else "not "
+        return utils.matches_filename(
+            path,
+            patterns=self.options.exclude,
+            log_message='"%(path)s" has %(whether)sbeen excluded',
+            logger=LOG,
         )
-        return match
 
     def make_checkers(self, paths=None):
         # type: (List[str]) -> NoneType
diff -r -u -x .idea -x .git pc/flake8/src/flake8/defaults.py flake8/src/flake8/defaults.py
--- pc/flake8/src/flake8/defaults.py	2018-12-03 22:40:13.000000000 -0800
+++ flake8/src/flake8/defaults.py	2018-12-03 15:24:23.000000000 -0800
@@ -30,7 +30,7 @@
     # ``# noqa: E123,W451,F921``
     # ``# NoQA: E123,W451,F921``
     # ``# NOQA: E123,W451,F921``
-    # We do not care about the ``: `` that follows ``noqa``
+    # We do not want to capture the ``: `` that follows ``noqa``
     # We do not care about the casing of ``noqa``
     # We want a comma-separated list of errors
     r"# noqa(?:: (?P<codes>([A-Z][0-9]+(?:[,\s]+)?)+))?",
diff -r -u -x .idea -x .git pc/flake8/src/flake8/main/application.py flake8/src/flake8/main/application.py
--- pc/flake8/src/flake8/main/application.py	2018-12-03 22:40:13.000000000 -0800
+++ flake8/src/flake8/main/application.py	2018-12-03 15:24:23.000000000 -0800
@@ -65,8 +65,8 @@
         self.formatter = None
         #: The :class:`flake8.plugins.notifier.Notifier` for listening plugins
         self.listener_trie = None
-        #: The :class:`flake8.style_guide.StyleGuide` built from the user's
-        #: options
+        #: The :class:`flake8.style_guide.StyleGuideManager` built from the
+        #: user's options
         self.guide = None
         #: The :class:`flake8.checker.Manager` that will handle running all of
         #: the checks selected by the user.
@@ -169,7 +169,7 @@
         If :attr:`check_plugins`, :attr:`listening_plugins`, or
         :attr:`formatting_plugins` are ``None`` then this method will update
         them with the appropriate plugin manager instance. Given the expense
-        of finding plugins (via :mod:`pkg_resources`) we want this to be
+        of finding plugins (via :mod:`entrypoints`) we want this to be
         idempotent and so only update those attributes if they are ``None``.
         """
         if self.local_plugins is None:
@@ -238,16 +238,7 @@
 
     def formatter_for(self, formatter_plugin_name):
         """Retrieve the formatter class by plugin name."""
-        try:
-            default_formatter = self.formatting_plugins["default"]
-        except KeyError:
-            raise exceptions.ExecutionError(
-                "The 'default' Flake8 formatting plugin is unavailable. "
-                "This usually indicates that your setuptools is too old. "
-                "Please upgrade setuptools. If that does not fix the issue"
-                " please file an issue."
-            )
-
+        default_formatter = self.formatting_plugins["default"]
         formatter_plugin = self.formatting_plugins.get(formatter_plugin_name)
         if formatter_plugin is None:
             LOG.warning(
@@ -283,7 +274,7 @@
         # type: () -> NoneType
         """Initialize our StyleGuide."""
         if self.guide is None:
-            self.guide = style_guide.StyleGuide(
+            self.guide = style_guide.StyleGuideManager(
                 self.options, self.listener_trie, self.formatter
             )
 
diff -r -u -x .idea -x .git pc/flake8/src/flake8/main/debug.py flake8/src/flake8/main/debug.py
--- pc/flake8/src/flake8/main/debug.py	2018-12-03 22:40:13.000000000 -0800
+++ flake8/src/flake8/main/debug.py	2018-12-03 15:24:23.000000000 -0800
@@ -4,6 +4,8 @@
 import json
 import platform
 
+import entrypoints
+
 
 def print_information(
     option, option_string, value, parser, option_manager=None
@@ -64,7 +66,4 @@
 
 def dependencies():
     """Generate the list of dependencies we care about."""
-    # defer this expensive import, not used outside --bug-report
-    import setuptools
-
-    return [{"dependency": "setuptools", "version": setuptools.__version__}]
+    return [{"dependency": "entrypoints", "version": entrypoints.__version__}]
diff -r -u -x .idea -x .git pc/flake8/src/flake8/main/options.py flake8/src/flake8/main/options.py
--- pc/flake8/src/flake8/main/options.py	2018-12-03 22:40:13.000000000 -0800
+++ flake8/src/flake8/main/options.py	2018-12-03 15:25:14.000000000 -0800
@@ -1,5 +1,6 @@
 """Contains the logic for all of the default options for Flake8."""
 from flake8 import defaults
+from flake8 import utils
 from flake8.main import debug
 from flake8.main import vcs
 
@@ -19,7 +20,9 @@
     - ``--hang-closing``
     - ``--ignore``
     - ``--extend-ignore``
+    - ``--per-file-ignores``
     - ``--max-line-length``
+    - ``--max-doc-length``
     - ``--select``
     - ``--disable-noqa``
     - ``--show-source``
@@ -143,6 +146,18 @@
     )
 
     add_option(
+        "--per-file-ignores",
+        parse_from_config=True,
+        comma_separated_list=True,
+        separator=utils.NEWLINE_SEPARATED_LIST_RE,
+        help="A pairing of filenames and violation codes that defines which "
+        "violations to ignore in a particular file. The filenames can be "
+        "specified in a manner similar to the ``--exclude`` option and the "
+        "violations work similarly to the ``--ignore`` and ``--select`` "
+        "options.",
+    )
+
+    add_option(
         "--max-line-length",
         type="int",
         metavar="n",
@@ -153,6 +168,12 @@
     )
 
     add_option(
+        '--max-doc-length', type='int', metavar='n',
+        default=None, parse_from_config=True,
+        help='Maximum allowed doc line length for the entirety of this run.'
+    )
+
+    add_option(
         "--select",
         metavar="errors",
         default=",".join(defaults.SELECT),
diff -r -u -x .idea -x .git pc/flake8/src/flake8/options/manager.py flake8/src/flake8/options/manager.py
--- pc/flake8/src/flake8/options/manager.py	2018-12-03 22:40:13.000000000 -0800
+++ flake8/src/flake8/options/manager.py	2018-12-03 15:24:23.000000000 -0800
@@ -32,6 +32,7 @@
         parse_from_config=False,
         comma_separated_list=False,
         normalize_paths=False,
+        separator=None,
     ):
         """Initialize an Option instance wrapping optparse.Option.
 
@@ -79,6 +80,8 @@
         :param bool normalize_paths:
             Whether the option is expecting a path or list of paths and should
             attempt to normalize the paths to absolute paths.
+        :param separator:
+            The item that separates the "comma"-separated list.
         """
         self.short_option_name = short_option_name
         self.long_option_name = long_option_name
@@ -107,6 +110,7 @@
         self.parse_from_config = parse_from_config
         self.comma_separated_list = comma_separated_list
         self.normalize_paths = normalize_paths
+        self.separator = separator or utils.COMMA_SEPARATED_LIST_RE
 
         self.config_name = None
         if parse_from_config:
diff -r -u -x .idea -x .git pc/flake8/src/flake8/plugins/manager.py flake8/src/flake8/plugins/manager.py
--- pc/flake8/src/flake8/plugins/manager.py	2018-12-03 22:40:13.000000000 -0800
+++ flake8/src/flake8/plugins/manager.py	2018-12-03 15:24:23.000000000 -0800
@@ -2,7 +2,7 @@
 import logging
 import sys
 
-import pkg_resources
+import entrypoints
 
 from flake8 import exceptions
 from flake8 import utils
@@ -143,17 +143,8 @@
         r"""Call the plugin with \*args and \*\*kwargs."""
         return self.plugin(*args, **kwargs)  # pylint: disable=not-callable
 
-    def _load(self, verify_requirements):
-        # Avoid relying on hasattr() here.
-        resolve = getattr(self.entry_point, "resolve", None)
-        require = getattr(self.entry_point, "require", None)
-        if resolve and require:
-            if verify_requirements:
-                LOG.debug('Verifying plugin "%s"\'s requirements.', self.name)
-                require()
-            self._plugin = resolve()
-        else:
-            self._plugin = self.entry_point.load(require=verify_requirements)
+    def _load(self):
+        self._plugin = self.entry_point.load()
         if not callable(self._plugin):
             msg = (
                 "Plugin %r is not a callable. It might be written for an"
@@ -163,23 +154,20 @@
             LOG.critical(msg)
             raise TypeError(msg)
 
-    def load_plugin(self, verify_requirements=False):
+    def load_plugin(self):
         """Retrieve the plugin for this entry-point.
 
         This loads the plugin, stores it on the instance and then returns it.
         It does not reload it after the first time, it merely returns the
         cached plugin.
 
-        :param bool verify_requirements:
-            Whether or not to make setuptools verify that the requirements for
-            the plugin are satisfied.
         :returns:
             Nothing
         """
         if self._plugin is None:
             LOG.info('Loading plugin "%s" from entry-point.', self.name)
             try:
-                self._load(verify_requirements)
+                self._load()
             except Exception as load_exception:
                 LOG.exception(load_exception)
                 failed_to_load = exceptions.FailedToLoadPlugin(
@@ -246,21 +234,15 @@
 class PluginManager(object):  # pylint: disable=too-few-public-methods
     """Find and manage plugins consistently."""
 
-    def __init__(
-        self, namespace, verify_requirements=False, local_plugins=None
-    ):
+    def __init__(self, namespace, local_plugins=None):
         """Initialize the manager.
 
         :param str namespace:
             Namespace of the plugins to manage, e.g., 'flake8.extension'.
         :param list local_plugins:
             Plugins from config (as "X = path.to:Plugin" strings).
-        :param bool verify_requirements:
-            Whether or not to make setuptools verify that the requirements for
-            the plugin are satisfied.
         """
         self.namespace = namespace
-        self.verify_requirements = verify_requirements
         self.plugins = {}
         self.names = []
         self._load_local_plugins(local_plugins or [])
@@ -273,12 +255,14 @@
             Plugins from config (as "X = path.to:Plugin" strings).
         """
         for plugin_str in local_plugins:
-            entry_point = pkg_resources.EntryPoint.parse(plugin_str)
+            name, _, entry_str = plugin_str.partition("=")
+            name, entry_str = name.strip(), entry_str.strip()
+            entry_point = entrypoints.EntryPoint.from_string(entry_str, name)
             self._load_plugin_from_entrypoint(entry_point, local=True)
 
     def _load_entrypoint_plugins(self):
         LOG.info('Loading entry-points for "%s".', self.namespace)
-        for entry_point in pkg_resources.iter_entry_points(self.namespace):
+        for entry_point in entrypoints.get_group_all(self.namespace):
             self._load_plugin_from_entrypoint(entry_point)
 
     def _load_plugin_from_entrypoint(self, entry_point, local=False):
@@ -339,7 +323,7 @@
 
 def version_for(plugin):
     # (Plugin) -> Union[str, NoneType]
-    """Determine the version of a plugin by it's module.
+    """Determine the version of a plugin by its module.
 
     :param plugin:
         The loaded plugin
diff -r -u -x .idea -x .git pc/flake8/src/flake8/processor.py flake8/src/flake8/processor.py
--- pc/flake8/src/flake8/processor.py	2018-12-03 22:39:46.000000000 -0800
+++ flake8/src/flake8/processor.py	2018-12-03 15:25:14.000000000 -0800
@@ -37,6 +37,7 @@
     - :attr:`line_number`
     - :attr:`logical_line`
     - :attr:`max_line_length`
+    - :attr:`max_doc_length`
     - :attr:`multiline`
     - :attr:`noqa`
     - :attr:`previous_indent_level`
@@ -82,6 +83,8 @@
         self.logical_line = ""
         #: Maximum line length as configured by the user
         self.max_line_length = options.max_line_length
+        #: Maximum doc line length as configured by the user
+        self.max_doc_length = options.max_doc_length
         #: Whether the current physical line is multiline
         self.multiline = False
         #: Whether or not we're observing NoQA
diff -r -u -x .idea -x .git pc/flake8/src/flake8/style_guide.py flake8/src/flake8/style_guide.py
--- pc/flake8/src/flake8/style_guide.py	2018-12-03 22:40:13.000000000 -0800
+++ flake8/src/flake8/style_guide.py	2018-12-03 15:24:23.000000000 -0800
@@ -1,6 +1,7 @@
 """Implementation of the StyleGuide used by Flake8."""
 import collections
 import contextlib
+import copy
 import enum
 import functools
 import itertools
@@ -321,10 +322,122 @@
         return decision
 
 
+class StyleGuideManager(object):
+    """Manage multiple style guides for a single run."""
+
+    def __init__(self, options, listener_trie, formatter, decider=None):
+        """Initialize our StyleGuide.
+
+        .. todo:: Add parameter documentation.
+        """
+        self.options = options
+        self.listener = listener_trie
+        self.formatter = formatter
+        self.stats = statistics.Statistics()
+        self.decider = decider or DecisionEngine(options)
+        self.style_guides = []
+        self.default_style_guide = StyleGuide(
+            options, listener_trie, formatter, decider=decider
+        )
+        self.style_guides = list(
+            itertools.chain(
+                [self.default_style_guide],
+                self.populate_style_guides_with(options),
+            )
+        )
+
+    def populate_style_guides_with(self, options):
+        """Generate style guides from the per-file-ignores option.
+
+        :param options:
+            The original options parsed from the CLI and config file.
+        :type options:
+            :class:`~optparse.Values`
+        :returns:
+            A copy of the default style guide with overridden values.
+        :rtype:
+            :class:`~flake8.style_guide.StyleGuide`
+        """
+        for value in options.per_file_ignores:
+            filename, violations_str = value.split(":")
+            violations = utils.parse_comma_separated_list(violations_str)
+            yield self.default_style_guide.copy(
+                filename=filename, extend_ignore_with=violations
+            )
+
+    def style_guide_for(self, filename):
+        """Find the StyleGuide for the filename in particular."""
+        guides = sorted(
+            (g for g in self.style_guides if g.applies_to(filename)),
+            key=lambda g: len(g.filename or ""),
+        )
+        if len(guides) > 1:
+            return guides[-1]
+        return guides[0]
+
+    @contextlib.contextmanager
+    def processing_file(self, filename):
+        """Record the fact that we're processing the file's results."""
+        guide = self.style_guide_for(filename)
+        with guide.processing_file(filename):
+            yield guide
+
+    def handle_error(
+        self,
+        code,
+        filename,
+        line_number,
+        column_number,
+        text,
+        physical_line=None,
+    ):
+        # type: (str, str, int, int, str) -> int
+        """Handle an error reported by a check.
+
+        :param str code:
+            The error code found, e.g., E123.
+        :param str filename:
+            The file in which the error was found.
+        :param int line_number:
+            The line number (where counting starts at 1) at which the error
+            occurs.
+        :param int column_number:
+            The column number (where counting starts at 1) at which the error
+            occurs.
+        :param str text:
+            The text of the error message.
+        :param str physical_line:
+            The actual physical line causing the error.
+        :returns:
+            1 if the error was reported. 0 if it was ignored. This is to allow
+            for counting of the number of errors found that were not ignored.
+        :rtype:
+            int
+        """
+        guide = self.style_guide_for(filename)
+        return guide.handle_error(
+            code, filename, line_number, column_number, text, physical_line
+        )
+
+    def add_diff_ranges(self, diffinfo):
+        """Update the StyleGuides to filter out information not in the diff.
+
+        This provides information to the underlying StyleGuides so that only
+        the errors in the line number ranges are reported.
+
+        :param dict diffinfo:
+            Dictionary mapping filenames to sets of line number ranges.
+        """
+        for guide in self.style_guides.values():
+            guide.add_diff_ranges(diffinfo)
+
+
 class StyleGuide(object):
     """Manage a Flake8 user's style guide."""
 
-    def __init__(self, options, listener_trie, formatter, decider=None):
+    def __init__(
+        self, options, listener_trie, formatter, filename=None, decider=None
+    ):
         """Initialize our StyleGuide.
 
         .. todo:: Add parameter documentation.
@@ -334,8 +447,24 @@
         self.formatter = formatter
         self.stats = statistics.Statistics()
         self.decider = decider or DecisionEngine(options)
+        self.filename = filename
+        if self.filename:
+            self.filename = utils.normalize_path(self.filename)
         self._parsed_diff = {}
 
+    def __repr__(self):
+        """Make it easier to debug which StyleGuide we're using."""
+        return "<StyleGuide [{}]>".format(self.filename)
+
+    def copy(self, filename=None, extend_ignore_with=None, **kwargs):
+        """Create a copy of this style guide with different values."""
+        filename = filename or self.filename
+        options = copy.deepcopy(self.options)
+        options.ignore.extend(extend_ignore_with or [])
+        return StyleGuide(
+            options, self.listener, self.formatter, filename=filename
+        )
+
     @contextlib.contextmanager
     def processing_file(self, filename):
         """Record the fact that we're processing the file's results."""
@@ -343,6 +472,26 @@
         yield self
         self.formatter.finished(filename)
 
+    def applies_to(self, filename):
+        """Check if this StyleGuide applies to the file.
+
+        :param str filename:
+            The name of the file with violations that we're potentially
+            applying this StyleGuide to.
+        :returns:
+            True if this applies, False otherwise
+        :rtype:
+            bool
+        """
+        if self.filename is None:
+            return True
+        return utils.matches_filename(
+            filename,
+            patterns=[self.filename],
+            log_message='{!r} does %(whether)smatch "%(path)s"'.format(self),
+            logger=LOG,
+        )
+
     def should_report_error(self, code):
         # type: (str) -> Decision
         """Determine if the error code should be reported or ignored.
diff -r -u -x .idea -x .git pc/flake8/src/flake8/utils.py flake8/src/flake8/utils.py
--- pc/flake8/src/flake8/utils.py	2018-12-03 22:40:13.000000000 -0800
+++ flake8/src/flake8/utils.py	2018-12-03 15:24:23.000000000 -0800
@@ -11,6 +11,7 @@
 
 DIFF_HUNK_REGEXP = re.compile(r"^@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@.*$")
 COMMA_SEPARATED_LIST_RE = re.compile(r"[,\s]")
+NEWLINE_SEPARATED_LIST_RE = re.compile(r"[\s]")
 LOCAL_PLUGIN_LIST_RE = re.compile(r"[,\t\n\r\f\v]")
 
 
@@ -335,6 +336,38 @@
     return parameters
 
 
+def matches_filename(path, patterns, log_message, logger):
+    """Use fnmatch to discern if a path exists in patterns.
+
+    :param str path:
+        The path to the file under question
+    :param patterns:
+        The patterns to match the path against.
+    :type patterns:
+        list[str]
+    :param str log_message:
+        The message used for logging purposes.
+    :returns:
+        True if path matches patterns, False otherwise
+    :rtype:
+        bool
+    """
+    if not patterns:
+        return False
+    basename = os.path.basename(path)
+    if fnmatch(basename, patterns):
+        logger.debug(log_message, {"path": basename, "whether": ""})
+        return True
+
+    absolute_path = os.path.abspath(path)
+    match = fnmatch(absolute_path, patterns)
+    logger.debug(
+        log_message,
+        {"path": absolute_path, "whether": "" if match else "not "},
+    )
+    return match
+
+
 def get_python_version():
     """Find and format the python implementation and version.
 
diff -r -u -x .idea -x .git pc/flake8/tests/integration/test_checker.py flake8/tests/integration/test_checker.py
--- pc/flake8/tests/integration/test_checker.py	2018-12-03 22:40:13.000000000 -0800
+++ flake8/tests/integration/test_checker.py	2018-12-03 15:24:23.000000000 -0800
@@ -51,13 +51,12 @@
 def test_handle_file_plugins(plugin_target):
     """Test the FileChecker class handling different file plugin types."""
     # Mock an entry point returning the plugin target
-    entry_point = mock.Mock(spec=['require', 'resolve', 'load'])
+    entry_point = mock.Mock(spec=['load'])
     entry_point.name = plugin_target.name
-    entry_point.resolve.return_value = plugin_target
+    entry_point.load.return_value = plugin_target
 
     # Load the checker plugins using the entry point mock
-    with mock.patch('pkg_resources.iter_entry_points',
-                    return_value=[entry_point]):
+    with mock.patch('entrypoints.get_group_all', return_value=[entry_point]):
         checks = manager.Checkers()
 
     # Prevent it from reading lines from stdin or somewhere else
diff -r -u -x .idea -x .git pc/flake8/tests/unit/test_application.py flake8/tests/unit/test_application.py
--- pc/flake8/tests/unit/test_application.py	2018-12-03 22:40:13.000000000 -0800
+++ flake8/tests/unit/test_application.py	2018-12-03 15:24:23.000000000 -0800
@@ -4,7 +4,6 @@
 import mock
 import pytest
 
-from flake8 import exceptions
 from flake8.main import application as app
 
 
@@ -61,14 +60,6 @@
     assert excinfo.value.args[0] is value
 
 
-def test_missing_default_formatter(application):
-    """Verify we raise an ExecutionError when there's no default formatter."""
-    application.formatting_plugins = {}
-
-    with pytest.raises(exceptions.ExecutionError):
-        application.formatter_for('fake-plugin-name')
-
-
 def test_warns_on_unknown_formatter_plugin_name(application):
     """Verify we log a warning with an unfound plugin."""
     default = mock.Mock()
diff -r -u -x .idea -x .git pc/flake8/tests/unit/test_debug.py flake8/tests/unit/test_debug.py
--- pc/flake8/tests/unit/test_debug.py	2018-12-03 22:40:13.000000000 -0800
+++ flake8/tests/unit/test_debug.py	2018-12-03 15:24:23.000000000 -0800
@@ -1,7 +1,7 @@
 """Tests for our debugging module."""
+import entrypoints
 import mock
 import pytest
-import setuptools
 
 from flake8.main import debug
 from flake8.options import manager
@@ -9,8 +9,8 @@
 
 def test_dependencies():
     """Verify that we format our dependencies appropriately."""
-    expected = [{'dependency': 'setuptools',
-                 'version': setuptools.__version__}]
+    expected = [{'dependency': 'entrypoints',
+                 'version': entrypoints.__version__}]
     assert expected == debug.dependencies()
 
 
@@ -46,8 +46,8 @@
                      'is_local': False},
                     {'plugin': 'pycodestyle', 'version': '2.0.0',
                      'is_local': False}],
-        'dependencies': [{'dependency': 'setuptools',
-                          'version': setuptools.__version__}],
+        'dependencies': [{'dependency': 'entrypoints',
+                          'version': entrypoints.__version__}],
         'platform': {
             'python_implementation': 'CPython',
             'python_version': '3.5.3',
diff -r -u -x .idea -x .git pc/flake8/tests/unit/test_file_processor.py flake8/tests/unit/test_file_processor.py
--- pc/flake8/tests/unit/test_file_processor.py	2018-12-03 22:40:13.000000000 -0800
+++ flake8/tests/unit/test_file_processor.py	2018-12-03 15:24:23.000000000 -0800
@@ -3,11 +3,11 @@
 import optparse
 import tokenize
 
-from flake8 import processor
-
 import mock
 import pytest
 
+from flake8 import processor
+
 
 def options_from(**kwargs):
     """Generate a Values instances with our kwargs."""
@@ -27,7 +27,7 @@
                for line in lines)
 
 
-def lines_from_file(tmpdir, contents):
+def _lines_from_file(tmpdir, contents):
     f = tmpdir.join('f.py')
     # be careful to write the bytes exactly to avoid newline munging
     f.write_binary(contents)
@@ -36,21 +36,19 @@
 
 def test_read_lines_universal_newlines(tmpdir):
     r"""Verify that line endings are translated to \n."""
-    lines = lines_from_file(tmpdir, b'# coding: utf-8\r\nx = 1\r\n')
+    lines = _lines_from_file(tmpdir, b'# coding: utf-8\r\nx = 1\r\n')
     assert lines == ['# coding: utf-8\n', 'x = 1\n']
 
 
 def test_read_lines_incorrect_utf_16(tmpdir):
-    """Verify that a file which incorrectly claims it is utf16 is still read
-    as latin-1.
-    """
-    lines = lines_from_file(tmpdir, b'# coding: utf16\nx = 1\n')
+    """Verify that an incorrectly encoded file is read as latin-1."""
+    lines = _lines_from_file(tmpdir, b'# coding: utf16\nx = 1\n')
     assert lines == ['# coding: utf16\n', 'x = 1\n']
 
 
 def test_read_lines_unknown_encoding(tmpdir):
     """Verify that an unknown encoding is still read as latin-1."""
-    lines = lines_from_file(tmpdir, b'# coding: fake-encoding\nx = 1\n')
+    lines = _lines_from_file(tmpdir, b'# coding: fake-encoding\nx = 1\n')
     assert lines == ['# coding: fake-encoding\n', 'x = 1\n']
 
 
@@ -329,9 +327,9 @@
 ])
 def test_log_token(token, log_string):
     """Verify we use the log object passed in."""
-    LOG = mock.Mock()
-    processor.log_token(LOG, token)
-    LOG.log.assert_called_once_with(
+    log = mock.Mock()
+    processor.log_token(log, token)
+    log.log.assert_called_once_with(
         5,  # flake8._EXTRA_VERBOSE
         log_string,
     )
@@ -352,5 +350,6 @@
 
 
 def test_nonexistent_file():
+    """Verify that FileProcessor raises IOError when a file does not exist."""
     with pytest.raises(IOError):
         processor.FileProcessor("foobar.py", options_from())
diff -r -u -x .idea -x .git pc/flake8/tests/unit/test_plugin.py flake8/tests/unit/test_plugin.py
--- pc/flake8/tests/unit/test_plugin.py	2018-12-03 22:40:13.000000000 -0800
+++ flake8/tests/unit/test_plugin.py	2018-12-03 15:24:23.000000000 -0800
@@ -14,48 +14,24 @@
     plugin = manager.Plugin('T000', entry_point)
 
     plugin.load_plugin()
-    entry_point.load.assert_called_once_with(require=False)
-
-
-def test_load_plugin_avoids_deprecated_entry_point_methods():
-    """Verify we use the preferred methods on new versions of setuptools."""
-    entry_point = mock.Mock(spec=['require', 'resolve', 'load'])
-    plugin = manager.Plugin('T000', entry_point)
-
-    plugin.load_plugin(verify_requirements=True)
-    assert entry_point.load.called is False
-    entry_point.require.assert_called_once_with()
-    entry_point.resolve.assert_called_once_with()
+    entry_point.load.assert_called_once_with()
 
 
 def test_load_plugin_is_idempotent():
     """Verify we use the preferred methods on new versions of setuptools."""
-    entry_point = mock.Mock(spec=['require', 'resolve', 'load'])
+    entry_point = mock.Mock(spec=['load'])
     plugin = manager.Plugin('T000', entry_point)
 
-    plugin.load_plugin(verify_requirements=True)
-    plugin.load_plugin(verify_requirements=True)
     plugin.load_plugin()
-    assert entry_point.load.called is False
-    entry_point.require.assert_called_once_with()
-    entry_point.resolve.assert_called_once_with()
-
-
-def test_load_plugin_only_calls_require_when_verifying_requirements():
-    """Verify we do not call require when verify_requirements is False."""
-    entry_point = mock.Mock(spec=['require', 'resolve', 'load'])
-    plugin = manager.Plugin('T000', entry_point)
-
     plugin.load_plugin()
-    assert entry_point.load.called is False
-    assert entry_point.require.called is False
-    entry_point.resolve.assert_called_once_with()
+    plugin.load_plugin()
+    entry_point.load.assert_called_once_with()
 
 
 def test_load_plugin_catches_and_reraises_exceptions():
     """Verify we raise our own FailedToLoadPlugin."""
-    entry_point = mock.Mock(spec=['require', 'resolve'])
-    entry_point.resolve.side_effect = ValueError('Test failure')
+    entry_point = mock.Mock(spec=['load'])
+    entry_point.load.side_effect = ValueError('Test failure')
     plugin = manager.Plugin('T000', entry_point)
 
     with pytest.raises(exceptions.FailedToLoadPlugin):
@@ -64,27 +40,27 @@
 
 def test_load_noncallable_plugin():
     """Verify that we do not load a non-callable plugin."""
-    entry_point = mock.Mock(spec=['require', 'resolve', 'load'])
-    entry_point.resolve.return_value = mock.NonCallableMock()
+    entry_point = mock.Mock(spec=['load'])
+    entry_point.load.return_value = mock.NonCallableMock()
     plugin = manager.Plugin('T000', entry_point)
 
     with pytest.raises(exceptions.FailedToLoadPlugin):
         plugin.load_plugin()
-    entry_point.resolve.assert_called_once_with()
+    entry_point.load.assert_called_once_with()
 
 
 def test_plugin_property_loads_plugin_on_first_use():
     """Verify that we load our plugin when we first try to use it."""
-    entry_point = mock.Mock(spec=['require', 'resolve', 'load'])
+    entry_point = mock.Mock(spec=['load'])
     plugin = manager.Plugin('T000', entry_point)
 
     assert plugin.plugin is not None
-    entry_point.resolve.assert_called_once_with()
+    entry_point.load.assert_called_once_with()
 
 
 def test_execute_calls_plugin_with_passed_arguments():
     """Verify that we pass arguments directly to the plugin."""
-    entry_point = mock.Mock(spec=['require', 'resolve', 'load'])
+    entry_point = mock.Mock(spec=['load'])
     plugin_obj = mock.Mock()
     plugin = manager.Plugin('T000', entry_point)
     plugin._plugin = plugin_obj
@@ -96,13 +72,11 @@
 
     # Extra assertions
     assert entry_point.load.called is False
-    assert entry_point.require.called is False
-    assert entry_point.resolve.called is False
 
 
 def test_version_proxies_to_the_plugin():
     """Verify that we pass arguments directly to the plugin."""
-    entry_point = mock.Mock(spec=['require', 'resolve', 'load'])
+    entry_point = mock.Mock(spec=['load'])
     plugin_obj = mock.Mock(spec_set=['version'])
     plugin_obj.version = 'a.b.c'
     plugin = manager.Plugin('T000', entry_point)
@@ -114,7 +88,7 @@
 def test_register_options():
     """Verify we call add_options on the plugin only if it exists."""
     # Set up our mocks and Plugin object
-    entry_point = mock.Mock(spec=['require', 'resolve', 'load'])
+    entry_point = mock.Mock(spec=['load'])
     plugin_obj = mock.Mock(spec_set=['name', 'version', 'add_options',
                                      'parse_options'])
     option_manager = mock.Mock(spec=['register_plugin'])
@@ -131,7 +105,7 @@
 def test_register_options_checks_plugin_for_method():
     """Verify we call add_options on the plugin only if it exists."""
     # Set up our mocks and Plugin object
-    entry_point = mock.Mock(spec=['require', 'resolve', 'load'])
+    entry_point = mock.Mock(spec=['load'])
     plugin_obj = mock.Mock(spec_set=['name', 'version', 'parse_options'])
     option_manager = mock.Mock(spec=['register_plugin'])
     plugin = manager.Plugin('T000', entry_point)
@@ -147,7 +121,7 @@
 def test_provide_options():
     """Verify we call add_options on the plugin only if it exists."""
     # Set up our mocks and Plugin object
-    entry_point = mock.Mock(spec=['require', 'resolve', 'load'])
+    entry_point = mock.Mock(spec=['load'])
     plugin_obj = mock.Mock(spec_set=['name', 'version', 'add_options',
                                      'parse_options'])
     option_values = optparse.Values({'enable_extensions': []})
diff -r -u -x .idea -x .git pc/flake8/tests/unit/test_plugin_manager.py flake8/tests/unit/test_plugin_manager.py
--- pc/flake8/tests/unit/test_plugin_manager.py	2018-12-03 22:40:13.000000000 -0800
+++ flake8/tests/unit/test_plugin_manager.py	2018-12-03 15:24:23.000000000 -0800
@@ -11,51 +11,51 @@
     return ep
 
 
-@mock.patch('pkg_resources.iter_entry_points')
-def test_calls_pkg_resources_on_instantiation(iter_entry_points):
-    """Verify that we call iter_entry_points when we create a manager."""
-    iter_entry_points.return_value = []
-    manager.PluginManager(namespace='testing.pkg_resources')
+@mock.patch('entrypoints.get_group_all')
+def test_calls_entrypoints_on_instantiation(get_group_all):
+    """Verify that we call get_group_all when we create a manager."""
+    get_group_all.return_value = []
+    manager.PluginManager(namespace='testing.entrypoints')
 
-    iter_entry_points.assert_called_once_with('testing.pkg_resources')
+    get_group_all.assert_called_once_with('testing.entrypoints')
 
 
-@mock.patch('pkg_resources.iter_entry_points')
-def test_calls_pkg_resources_creates_plugins_automaticaly(iter_entry_points):
+@mock.patch('entrypoints.get_group_all')
+def test_calls_entrypoints_creates_plugins_automaticaly(get_group_all):
     """Verify that we create Plugins on instantiation."""
-    iter_entry_points.return_value = [
+    get_group_all.return_value = [
         create_entry_point_mock('T100'),
         create_entry_point_mock('T200'),
     ]
-    plugin_mgr = manager.PluginManager(namespace='testing.pkg_resources')
+    plugin_mgr = manager.PluginManager(namespace='testing.entrypoints')
 
-    iter_entry_points.assert_called_once_with('testing.pkg_resources')
+    get_group_all.assert_called_once_with('testing.entrypoints')
     assert 'T100' in plugin_mgr.plugins
     assert 'T200' in plugin_mgr.plugins
     assert isinstance(plugin_mgr.plugins['T100'], manager.Plugin)
     assert isinstance(plugin_mgr.plugins['T200'], manager.Plugin)
 
 
-@mock.patch('pkg_resources.iter_entry_points')
-def test_handles_mapping_functions_across_plugins(iter_entry_points):
+@mock.patch('entrypoints.get_group_all')
+def test_handles_mapping_functions_across_plugins(get_group_all):
     """Verify we can use the PluginManager call functions on all plugins."""
     entry_point_mocks = [
         create_entry_point_mock('T100'),
         create_entry_point_mock('T200'),
     ]
-    iter_entry_points.return_value = entry_point_mocks
-    plugin_mgr = manager.PluginManager(namespace='testing.pkg_resources')
+    get_group_all.return_value = entry_point_mocks
+    plugin_mgr = manager.PluginManager(namespace='testing.entrypoints')
     plugins = [plugin_mgr.plugins[name] for name in plugin_mgr.names]
 
     assert list(plugin_mgr.map(lambda x: x)) == plugins
 
 
-@mock.patch('pkg_resources.iter_entry_points')
-def test_local_plugins(iter_entry_points):
+@mock.patch('entrypoints.get_group_all')
+def test_local_plugins(get_group_all):
     """Verify PluginManager can load given local plugins."""
-    iter_entry_points.return_value = []
+    get_group_all.return_value = []
     plugin_mgr = manager.PluginManager(
-        namespace='testing.pkg_resources',
+        namespace='testing.entrypoints',
         local_plugins=['X = path.to:Plugin']
     )
 
diff -r -u -x .idea -x .git pc/flake8/tests/unit/test_style_guide.py flake8/tests/unit/test_style_guide.py
--- pc/flake8/tests/unit/test_style_guide.py	2018-12-03 22:40:13.000000000 -0800
+++ flake8/tests/unit/test_style_guide.py	2018-12-03 15:24:23.000000000 -0800
@@ -5,6 +5,7 @@
 import pytest
 
 from flake8 import style_guide
+from flake8 import utils
 from flake8.formatting import base
 from flake8.plugins import notifier
 
@@ -17,6 +18,7 @@
     kwargs.setdefault('extend_ignore', [])
     kwargs.setdefault('disable_noqa', False)
     kwargs.setdefault('enable_extensions', [])
+    kwargs.setdefault('per_file_ignores', [])
     return optparse.Values(kwargs)
 
 
@@ -81,3 +83,101 @@
         guide.handle_error(error_code, 'stdin', 1, 1, 'error found')
     assert listener_trie.notify.called is False
     assert formatter.handle.called is False
+
+
+def test_style_guide_manager():
+    """Verify how the StyleGuideManager creates a default style guide."""
+    listener_trie = mock.create_autospec(notifier.Notifier, instance=True)
+    formatter = mock.create_autospec(base.BaseFormatter, instance=True)
+    options = create_options()
+    guide = style_guide.StyleGuideManager(options,
+                                          listener_trie=listener_trie,
+                                          formatter=formatter)
+    assert guide.default_style_guide.options is options
+    assert len(guide.style_guides) == 1
+
+
+PER_FILE_IGNORES_UNPARSED = [
+    "first_file.py:W9",
+    "second_file.py:F4,F9",
+    "third_file.py:E3",
+    "sub_dir/*:F4",
+]
+
+
+@pytest.mark.parametrize('style_guide_file,filename,expected', [
+    ("first_file.py", "first_file.py", True),
+    ("first_file.py", "second_file.py", False),
+    ("sub_dir/*.py", "first_file.py", False),
+    ("sub_dir/*.py", "sub_dir/file.py", True),
+    ("sub_dir/*.py", "other_dir/file.py", False),
+])
+def test_style_guide_applies_to(style_guide_file, filename, expected):
+    """Verify that we match a file to its style guide."""
+    listener_trie = mock.create_autospec(notifier.Notifier, instance=True)
+    formatter = mock.create_autospec(base.BaseFormatter, instance=True)
+    options = create_options()
+    guide = style_guide.StyleGuide(options,
+                                   listener_trie=listener_trie,
+                                   formatter=formatter,
+                                   filename=style_guide_file)
+    assert guide.applies_to(filename) is expected
+
+
+def test_style_guide_manager_pre_file_ignores_parsing():
+    """Verify how the StyleGuideManager creates a default style guide."""
+    listener_trie = mock.create_autospec(notifier.Notifier, instance=True)
+    formatter = mock.create_autospec(base.BaseFormatter, instance=True)
+    options = create_options(per_file_ignores=PER_FILE_IGNORES_UNPARSED)
+    guide = style_guide.StyleGuideManager(options,
+                                          listener_trie=listener_trie,
+                                          formatter=formatter)
+    assert len(guide.style_guides) == 5
+    assert list(map(utils.normalize_path,
+                    ["first_file.py", "second_file.py", "third_file.py",
+                        "sub_dir/*"])
+                ) == [g.filename for g in guide.style_guides[1:]]
+
+
+@pytest.mark.parametrize('ignores,violation,filename,handle_error_return', [
+    (['E1', 'E2'], 'F401', 'first_file.py', 1),
+    (['E1', 'E2'], 'E121', 'first_file.py', 0),
+    (['E1', 'E2'], 'F401', 'second_file.py', 0),
+    (['E1', 'E2'], 'F401', 'third_file.py', 1),
+    (['E1', 'E2'], 'E311', 'third_file.py', 0),
+    (['E1', 'E2'], 'F401', 'sub_dir/file.py', 0),
+])
+def test_style_guide_manager_pre_file_ignores(ignores, violation, filename,
+                                              handle_error_return):
+    """Verify how the StyleGuideManager creates a default style guide."""
+    listener_trie = mock.create_autospec(notifier.Notifier, instance=True)
+    formatter = mock.create_autospec(base.BaseFormatter, instance=True)
+    options = create_options(ignore=ignores,
+                             select=['E', 'F', 'W'],
+                             per_file_ignores=PER_FILE_IGNORES_UNPARSED)
+    guide = style_guide.StyleGuideManager(options,
+                                          listener_trie=listener_trie,
+                                          formatter=formatter)
+    assert (guide.handle_error(violation, filename, 1, 1, "Fake text")
+            == handle_error_return)
+
+
+@pytest.mark.parametrize('filename,expected', [
+    ('first_file.py', utils.normalize_path('first_file.py')),
+    ('second_file.py', utils.normalize_path('second_file.py')),
+    ('third_file.py', utils.normalize_path('third_file.py')),
+    ('fourth_file.py', None),
+    ('sub_dir/__init__.py', utils.normalize_path('sub_dir/*')),
+    ('other_dir/__init__.py', None),
+])
+def test_style_guide_manager_style_guide_for(filename, expected):
+    """Verify the style guide selection function."""
+    listener_trie = mock.create_autospec(notifier.Notifier, instance=True)
+    formatter = mock.create_autospec(base.BaseFormatter, instance=True)
+    options = create_options(per_file_ignores=PER_FILE_IGNORES_UNPARSED)
+    guide = style_guide.StyleGuideManager(options,
+                                          listener_trie=listener_trie,
+                                          formatter=formatter)
+
+    file_guide = guide.style_guide_for(filename)
+    assert file_guide.filename == expected
